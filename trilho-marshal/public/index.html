<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Painel + TV — 1080×1920</title>
  <style>
    :root{ --bg:#000; --text:#fff; --muted:#a9b4c2; --accent:#2dd19e; --frame:#333; }
    *{box-sizing:border-box; touch-action: none;}
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:var(--text);
      font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;
      display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
      min-height:100vh;overflow:auto
    }

    /* TV FIXA 1080x1920 */
    #tv{position:relative;width:100%;height:1920px;border:4px solid var(--frame);overflow:hidden;background:#111;border-radius:12px;flex-shrink:0;touch-action:none}

    /* MUNDO: contém a imagem e os objetos da cena (quadros). A CÂMERA move = aplicamos transform no WORLD */
    #world{position:absolute; left:0; top:0; width:max(100%, var(--imgW, 1080px)); height:max(100%, var(--imgH, 1920px)); transform-origin:top left; will-change:transform;}
    #img{position:absolute;top:0;left:0;width:auto;height:auto;max-width:none;max-height:none;image-rendering:auto}

    /* Grid (ex.: 10 cm por quadrado) */
    .grid{position:absolute;inset:0;pointer-events:none;background-size:var(--g) var(--g), var(--g) var(--g);background-position:0 0, 0 0;background-image:linear-gradient(to right, rgba(255,255,255,.12) 1px, transparent 1px),linear-gradient(to bottom, rgba(255,255,255,.12) 1px, transparent 1px);display:none}

    .info{position:absolute;left:10px;top:10px;padding:6px 10px;background:rgba(0,0,0,.55);border:1px solid #2a2a2a;border-radius:999px;font-size:12px;backdrop-filter:blur(6px);z-index:4}
    .opHUD{position:absolute;top:12px;right:12px;background:rgba(0,0,0,.6);border:1px solid #2a2a2a;color:#d7e7ff;border-radius:999px;padding:6px 10px;font-size:12px;backdrop-filter:blur(6px);z-index:5}
    .hidden{display:none!important}

    .controls{
      margin-top: 60px;
      margin-left: 20px;
      width:100%;
      max-width:1080px;
      position: absolute;
      top: 0;
      left: 0
    }

    label{font-size:13px;display:block;margin-bottom:6px}
    input[type=range], input[type=number], input[type=checkbox]{width:100%}
    input[type=range]{accent-color:var(--accent)}
    input[type=number]{padding:8px;border-radius:8px;border:1px solid #2a2a2a;background:#0c0c0c;color:var(--text)}
    .inline{display:flex;align-items:center;gap:8px}
    .hint{font-size:12px;color:var(--muted)}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0b0b0b;border:1px solid #2a2a2a;padding:1px 6px;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:1px solid #2a2a2a;background:#0c0c0c;color:var(--text);cursor:pointer}
    .btns{display:flex;gap:8px}

    /* Botão flutuante para mobile */
    .fab-toggle {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 50;
      padding: 10px 14px;
      background: rgba(0,0,0,.6);
      border: 1px solid #2a2a2a;
      border-radius: 999px;
      color: #fff;
      font-size: 14px;
      line-height: 1;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }
    .fab-toggle:active { transform: scale(0.98); }
    @media (min-width: 1100px) {
      .fab-toggle { right: 24px; top: 24px; }
    }

    /* QUADROS na parede (objetos fixos no mundo). Só ficam visíveis quando a câmera os “enxerga”. */
    .frame {
      position:absolute;
      border:2px solid rgba(255,255,255,.7);
      background:rgba(0,0,0,.35);
      color:#fff;
      font:12px/1.1 ui-monospace,Menlo,Consolas,monospace;
      padding:6px 8px;
      border-radius:10px;
      opacity:.15;
      transition:opacity .15s ease, transform .15s ease;
      pointer-events:none;
    }
    .frame.active {
      opacity:1;
      transform:scale(1.02);
      border-color:#fff;
      background:rgba(0,0,0,.15);
    }
  </style>
</head>
<body>
  <div id="tv">
    <div id="opHUD" class="opHUD hidden">
      • pos <span id="opPos">0</span>% — • tecla <b>C</b> para mostrar Controles
    </div>

    <!-- WORLD: a imagem e os quadros ficam aqui. O que “anda” é a CÂMERA (transform neste container). -->
    <div id="world">
      <img id="img" alt="arte" />
      <!-- Quadros instanciados dinamicamente via JS em #frames -->
      <div id="frames"></div>
    </div>

    <div id="grid" class="grid"></div>
    <div id="info" class="info">1080×1920 • escala 100% • pos 0% • off 0 / 0</div>
  </div>

  <button id="mobileToggle" class="fab-toggle mt-10" aria-label="Mostrar/ocultar controles">
    ☰ Controles
  </button>

  <div class="controls" id="controls">

    <div class="flex flex-col">
      <label>Carregar imagem
        <input id="file" type="file" accept="image/*" />
      </label>
    </div>

    <div class="mt-6 flex flex-col space-y-4">
      <label>Escala (%): <span id="sval">100</span>
        <input id="scale" type="range" min="5" max="400" step="0.1" value="100" />
      </label>
      <label>Posição no trilho (%): <span id="pval">0</span>
        <input id="pos" type="range" min="0" max="100" step="0.1" value="0" />
      </label>
      <label>Offset X (px): <span id="oxv">0</span>
        <input id="offX" type="range" min="-8000" max="8000" step="1" value="0" />
      </label>
      <label>Offset Y (px): <span id="oyv">0</span>
        <input id="offY" type="range" min="-8000" max="8000" step="1" value="0" />
      </label>
    </div>

    <div class="mt-6">

      <div class="btns">
        <button class="bg-white text-black px-4 py-2" id="save">Salvar preset</button>
        <button class="bg-white text-black px-4 py-2" id="clear">Limpar preset</button>
        <button class="bg-white text-black px-4 py-2" id="toggleMode"><span id="modeLabel">Controles</span> (C)</button>
      </div>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <input id="fs" type="checkbox" value="" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded-sm focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
      <label for="fs" class="ms-2 w-full text-sm font-medium text-gray-900 dark:text-gray-300">Tela cheia</label>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <input id="toggleGrid" type="checkbox" value="" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded-sm focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
      <label for="toggleGrid" class="ms-2 w-full text-sm font-medium text-gray-900 dark:text-gray-300">Grid</label>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <label>Tamanho do quadrado (px) — p/ 10 cm
        <input id="gridPx" type="number" min="10" max="800" value="100" />
      </label>
    </div>

  </div>

  <script>
    const $ = id => document.getElementById(id);
    const tv = $('tv');
    const world = $('world');
    const img = $('img');
    const framesLayer = $('frames');

    const file = $('file');
    const fs = $('fs');

    const scale = $('scale');
    const pos = $('pos');
    const offX = $('offX');
    const offY = $('offY');

    const sval = $('sval');
    const pval = $('pval');
    const oxv = $('oxv');
    const oyv = $('oyv');

    const grid = $('grid');
    const toggleGrid = $('toggleGrid');
    const gridPx = $('gridPx');

    const info = $('info');

    const controls = $('controls');
    const opHUD = $('opHUD');
    const opPos = $('opPos');
    const toggleModeBtn = $('toggleMode');
    const modeLabel = $('modeLabel');

    const saveBtn = $('save');
    const clearBtn = $('clear');

    const mobileToggle = $('mobileToggle');

    const LSKEY = 'tv_cal_preset_v1';
    const MODEKEY = 'tv_mode_v1';

    // QUADROS: serão posicionados ao longo da imagem (em px, coordenadas da arte).
    // Mantém o conceito de "objetos fixos no mundo". Eles entram/saem conforme a câmera.
    let FRAMES = []; // preenchido após carregar a imagem

    let S = {
      scale: 1,
      offX: 0,
      offY: 0,
      pos: 0,
      imgW: 0,
      imgH: 0,
      railLeftX: 0,
      railRightX: 0,
      gridPx: 100,
      showGrid: false,
      mode: 'cal' // 'cal' | 'op'
    };

    function saveLocal(){ localStorage.setItem(LSKEY, JSON.stringify(S)); localStorage.setItem(MODEKEY, S.mode); }
    function loadLocal(){
      const s = localStorage.getItem(LSKEY); if(s){ try{ S = {...S, ...JSON.parse(s)} }catch(e){} }
      const m = localStorage.getItem(MODEKEY); if(m){ S.mode = m; }
    }

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    // Mapeia a posição percentual (0–100) para X da câmera em pixels dentro da arte
    function cameraX(){ return S.railLeftX + (S.railRightX - S.railLeftX) * (S.pos/100); }

    // Atualiza quais quadros estão visíveis na janela 1080x1920 da câmera
    function updateFramesVisibility(){
      const camLeft = cameraX();
      const camRight = camLeft + 1080; // largura do viewport
      FRAMES.forEach(fr => {
        const inView = fr.x + fr.w > camLeft && fr.x < camRight && fr.y + fr.h > -S.offY && fr.y < (-S.offY + 1920);
        fr.el.classList.toggle('active', !!inView);
      });
    }

    function render(){
      sval.textContent = (S.scale*100).toFixed(1);
      pval.textContent = S.pos.toFixed(1);
      oxv.textContent = S.offX;
      oyv.textContent = S.offY;

      // === IMPLEMENTAÇÃO “CÂMERA MOVE”: aplicamos transform no WORLD ===
      const cx = cameraX();
      const tx = (-cx + S.offX) * S.scale;
      const ty = (S.offY) * S.scale;
      world.style.setProperty('--imgW', S.imgW + 'px');
      world.style.setProperty('--imgH', S.imgH + 'px');
      world.style.transform = `translate(${tx}px, ${ty}px) scale(${S.scale})`;

      // Grid
      grid.style.setProperty('--g', S.gridPx + 'px');
      grid.style.display = S.showGrid ? 'block' : 'none';

      info.textContent = `1080×1920 • escala ${(S.scale*100).toFixed(1)}% • pos ${S.pos.toFixed(1)}% • off ${S.offX} / ${S.offY}`;
      opPos.textContent = S.pos.toFixed(1);

      // UI por modo
      if(S.mode === 'op'){
        controls.classList.add('hidden');
        info.classList.add('hidden');
        opHUD.classList.remove('hidden');
        modeLabel && (modeLabel.textContent = 'Operação');
      } else {
        controls.classList.remove('hidden');
        info.classList.remove('hidden');
        opHUD.classList.add('hidden');
        modeLabel && (modeLabel.textContent = 'Controles');
      }

      updateFramesVisibility();
      saveLocal();
    }

    function instantiateFrames(){
      // Exemplo: 4 quadros distribuídos na largura da arte (A, B, C, D).
      // Você pode substituir por dados reais (x,y,w,h) conforme a arte.
      framesLayer.innerHTML = '';
      const margin = 100; // px
      const w = Math.min(400, Math.max(220, S.imgW * 0.12));
      const h = Math.min(300, Math.max(180, S.imgH * 0.15));
      const xs = [margin, S.imgW*0.33 - w/2, S.imgW*0.66 - w/2, S.imgW - w - margin];
      const ys = [S.imgH*0.25 - h/2, S.imgH*0.5 - h/2, S.imgH*0.75 - h/2, S.imgH*0.4 - h/2];

      FRAMES = xs.map((x,i)=>({
        id: String.fromCharCode(65+i), // A,B,C,D...
        x: Math.max(0, Math.min(S.imgW - w, x)),
        y: 0,
        y: Math.max(0, Math.min(S.imgH - h, ys[i%ys.length])),
        w, h,
        el: null
      }));

      FRAMES.forEach(fr=>{
        const el = document.createElement('div');
        el.className = 'frame';
        el.style.left = fr.x + 'px';
        el.style.top = fr.y + 'px';
        el.style.width = fr.w + 'px';
        el.style.height = fr.h + 'px';
        el.textContent = `Quadro ${fr.id}`;
        framesLayer.appendChild(el);
        fr.el = el;
      });
    }

    // ======= Input/UI existentes =======

    function setMode(m){
      S.mode = m;
      render();
    }

    file.addEventListener('change', e => {
      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      img.onload = () => {
        S.imgW = img.naturalWidth; S.imgH = img.naturalHeight;
        S.railLeftX = 0;
        S.railRightX = Math.max(0, S.imgW - 1080); // viewport é 1080 de largura
        instantiateFrames();
        render();
      };
      img.src = url;
    });

    scale.addEventListener('input', ()=>{ S.scale = parseFloat(scale.value)/100; render(); });
    pos.addEventListener('input', ()=>{ S.pos = parseFloat(pos.value); render(); });
    offX.addEventListener('input', ()=>{ S.offX = parseInt(offX.value,10); render(); });
    offY.addEventListener('input', ()=>{ S.offY = parseInt(offY.value,10); render(); });

    toggleGrid.addEventListener('change', ()=>{ S.showGrid = toggleGrid.checked; render(); });
    gridPx.addEventListener('input', ()=>{ S.gridPx = Math.max(2, parseInt(gridPx.value||'100',10)); render(); });

    saveBtn.addEventListener('click', ()=>{ saveLocal(); alert('Preset salvo.'); });
    clearBtn.addEventListener('click', ()=>{ localStorage.removeItem(LSKEY); alert('Preset limpo.'); });

    // Fullscreen opcional
    fs.addEventListener('change', async ()=>{
      if(fs.checked){ try{ await (document.body.requestFullscreen?.() || document.documentElement.requestFullscreen?.()); }catch(e){} }
      else { document.exitFullscreen?.(); }
    });

    // ======== TOUCH ========
    let lastTouch = null;   // {x,y}
    let pinch = null;       // {d0, s0, cx, cy}

    function tvPointFromTouch(t){ const r = tv.getBoundingClientRect(); return { x: t.clientX - r.left, y: t.clientY - r.top }; }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    tv.addEventListener('touchstart', (e)=>{
      if(S.mode === 'op'){
        if(e.touches.length===1){ lastTouch = tvPointFromTouch(e.touches[0]); }
        return;
      }
      if(e.touches.length===1){
        lastTouch = tvPointFromTouch(e.touches[0]);
      } else if(e.touches.length===2){
        const p1 = tvPointFromTouch(e.touches[0]);
        const p2 = tvPointFromTouch(e.touches[1]);
        const d0 = dist(p1,p2);
        const cx = (p1.x+p2.x)/2; const cy = (p1.y+p2.y)/2;
        pinch = { d0, s0: S.scale, cx, cy };
      }
    }, {passive:false});

    tv.addEventListener('touchmove', (e)=>{
      e.preventDefault();
      if(S.mode === 'op'){
        if(e.touches.length===1 && lastTouch){
          const p = tvPointFromTouch(e.touches[0]);
          const dx = p.x - lastTouch.x;            // arrasto horizontal
          const step = dx / 5;                      // sensibilidade
          S.pos = clamp(S.pos + step, 0, 100);
          pos.value = S.pos; lastTouch = p; render();
        }
        return;
      }
      if(e.touches.length===1 && lastTouch){
        const p = tvPointFromTouch(e.touches[0]);
        const dx = p.x - lastTouch.x; const dy = p.y - lastTouch.y;
        S.offX += Math.round(dx / S.scale);
        S.offY += Math.round(dy / S.scale);
        offX.value = S.offX; offY.value = S.offY;
        lastTouch = p; render();
      }
      if(e.touches.length===2 && pinch){
        const p1 = tvPointFromTouch(e.touches[0]);
        const p2 = tvPointFromTouch(e.touches[1]);
        const d1 = dist(p1,p2);
        let newScale = pinch.s0 * (d1 / pinch.d0);
        newScale = Math.min(4.0, Math.max(0.05, newScale));
        const s = S.scale, s2 = newScale; const cx = pinch.cx, cy = pinch.cy;
        S.offX = Math.round(S.offX + cx*(1/s2 - 1/s));
        S.offY = Math.round(S.offY + cy*(1/s2 - 1/s));
        S.scale = newScale; scale.value = (S.scale*100).toFixed(1);
        render();
      }
    }, {passive:false});

    tv.addEventListener('touchend', (e)=>{
      if(e.touches.length===0){ lastTouch=null; pinch=null; }
      if(e.touches.length===1){ pinch=null; lastTouch = tvPointFromTouch(e.touches[0]); }
    });

    // ======== WHEEL/SCROLL → move a CÂMERA (pos%) ========
    tv.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const sens = 0.04; // ajuste de sensibilidade do scroll
      S.pos = clamp(S.pos + e.deltaY * sens, 0, 100);
      pos.value = S.pos;
      render();
    }, {passive:false});

    // Teclado
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='c'){ setMode(S.mode==='cal'?'op':'cal'); return; }
      const step = e.shiftKey ? 10 : 1;
      if(S.mode==='cal' && e.altKey){
        if(e.key==='ArrowLeft'){ S.offX -= step; offX.value = S.offX; render(); }
        if(e.key==='ArrowRight'){ S.offX += step; offX.value = S.offX; render(); }
        if(e.key==='ArrowUp'){ S.offY -= step; offY.value = S.offY; render(); }
        if(e.key==='ArrowDown'){ S.offY += step; offY.value = S.offY; render(); }
      }
      if(e.key==='ArrowLeft' && !e.altKey){ S.pos = Math.max(0, S.pos - (e.shiftKey?5:1)); pos.value = S.pos; render(); }
      if(e.key==='ArrowRight' && !e.altKey){ S.pos = Math.min(100, S.pos + (e.shiftKey?5:1)); pos.value = S.pos; render(); }
    });

    // Toggle mobile/desktop
    mobileToggle.addEventListener('click', ()=> setMode(S.mode==='cal' ? 'op' : 'cal'));
    toggleModeBtn && toggleModeBtn.addEventListener('click', ()=> setMode(S.mode==='cal'?'op':'cal'));

    // Boot
    loadLocal();
    const urlMode = new URLSearchParams(location.search).get('mode');
    if(urlMode==='op'){ S.mode='op'; }
    scale.value = (S.scale*100).toFixed(1);
    offX.value = S.offX; offY.value = S.offY; pos.value = S.pos; gridPx.value = S.gridPx; toggleGrid.checked = S.showGrid;
    render();
  </script>
   <script src="https://cdn.tailwindcss.com"></script>
</body>
</html>